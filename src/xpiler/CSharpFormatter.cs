// Copyright (c) 2017, 2018 Jae-jun Kang
// See the file LICENSE for details.

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace x2net.xpiler
{
    class CSharpFormatter : Formatter
    {
        private const string Extension = ".cs";

        public override string Description { get { return "C#"; } }

        public override bool Format(Unit unit, string outDir)
        {
            try
            {
                var context = new CSharpFormatterContext()
                {
                    Unit = unit,
                    Target = Path.Combine(outDir, unit.BaseName + Extension)
                };
                using (var writer = new StreamWriter(new FileStream(context.Target, FileMode.Create)))
                {
                    context.Writer = writer;
                    FormatHead(context);
                    FormatBody(context);
                    writer.Flush();
                }
            }
            catch (IOException)
            {
                // mayt be in the middle of processing
                return true;
            }
            catch (Exception e)
            {
                Console.Error.WriteLine(e);
                return false;
            }
            return true;
        }

        private void FormatHead(CSharpFormatterContext context)
        {
            var o = context.Writer;
            o.WriteLine("// auto-generated by x2net.xpiler");
            o.WriteLine();
            o.WriteLine("using System;");
            o.WriteLine("using System.Collections.Generic;");
            o.WriteLine("using System.Text;");
            o.WriteLine();
            o.WriteLine("using x2net;");
            o.WriteLine();

            foreach (var reference in context.Unit.References)
            {
                reference.Format(context);
            }
        }

        private void FormatBody(CSharpFormatterContext context)
        {
            var o = context.Writer;
            if (!String.IsNullOrEmpty(context.Unit.Namespace))
            {
                o.WriteLine("namespace {0}", context.Unit.Namespace.Replace('/', '.'));
                o.WriteLine("{");
                context.Indent();
            }
            var leading = true;
            foreach (var def in context.Unit.Definitions)
            {
                if (leading)
                {
                    leading = false;
                }
                else
                {
                    context.NewLine();
                }
                def.Format(context);
            }
            if (!String.IsNullOrEmpty(context.Unit.Namespace))
            {
                context.Unindent();
                o.WriteLine("}");
            }
        }

        public override bool IsUpToDate(string path, string outDir)
        {
            var baseName = Path.GetFileNameWithoutExtension(path);
            var target = Path.Combine(outDir, baseName + Extension);
            return File.Exists(target) &&
                   File.GetLastWriteTime(target) >= File.GetLastWriteTime(path);
        }
    }

    class CSharpFormatterContext : FormatterContext
    {
        private const string Tab = "    ";

        private static Dictionary<string, string> nativeTypes;
        private static Dictionary<string, string> defaultValues;
        private static HashSet<string> keywords;

        private int baseIndentation = 0;

        static CSharpFormatterContext()
        {
            nativeTypes = new Dictionary<string, string>();
            nativeTypes.Add("bool", "bool");
            nativeTypes.Add("byte", "byte");
            nativeTypes.Add("bytes", "byte[]");
            nativeTypes.Add("int8", "sbyte");
            nativeTypes.Add("int16", "short");
            nativeTypes.Add("int32", "int");
            nativeTypes.Add("int64", "long");
            nativeTypes.Add("float32", "float");
            nativeTypes.Add("float64", "double");
            nativeTypes.Add("string", "string");
            nativeTypes.Add("datetime", "DateTime");
            nativeTypes.Add("list", "List");
            nativeTypes.Add("map", "Dictionary");

            defaultValues = new Dictionary<string, string>();
            defaultValues.Add("bool", "false");
            defaultValues.Add("byte", "0");
            defaultValues.Add("bytes", "null");
            defaultValues.Add("int8", "0");
            defaultValues.Add("int16", "0");
            defaultValues.Add("int32", "0");
            defaultValues.Add("int64", "0");
            defaultValues.Add("float32", ".0f");
            defaultValues.Add("float64", ".0");
            defaultValues.Add("datetime", "new DateTime(621355968000000000)");
            defaultValues.Add("string", "");

            keywords = new HashSet<string>  {
                "abstract","event","new","struct","as","explicit","null","switch","base","extern",
                "this","false","operator","throw","break","finally","out","true",
                "fixed","override","try","case","params","typeof","catch","for",
                "private","foreach","protected","checked","goto","public",
                "unchecked","class","if","readonly","unsafe","const","implicit","ref",
                "continue","in","return","using","virtual","default",
                "interface","sealed","volatile","delegate","internal","do","is",
                "sizeof","while","lock","stackalloc","else","static","enum",
                "namespace",
                "object","bool","byte","float","uint","char","ulong","ushort",
                "decimal","int","sbyte","short","double","long","string","void",
                "partial", "yield", "where"
            };
        }

        public string Target { get; set; }

        public override void FormatCell(CellDef def)
        {
            def.BaseClass = def.Base;
            if (String.IsNullOrEmpty(def.BaseClass))
            {
                def.BaseClass = (def.IsEvent ? "Event" : "Cell");
            }
            PreprocessProperties(def);

            FormatComment(0, def.Comment);
            Out(0, "public class {0} : {1}", def.Name, def.BaseClass);
            Out(0, "{");
            Out(1, "protected static new readonly Tag tag;");
            NewLine();
            if (def.IsEvent)
            {
                Out(1, "public static new int TypeId { get { return tag.TypeId; } }");
                NewLine();
            }
            FormatFields(def);
            if (def.HasProperties)
            {
                NewLine();
            }
            FormatProperties(def);
            if (def.HasProperties)
            {
                NewLine();
            }
            FormatMethods(def);
            Out(0, "}");
        }

        public override void FormatConsts(ConstsDef def)
        {
            if (nativeTypes.ContainsKey(def.Type))
            {
                def.NativeType = nativeTypes[def.Type];
            }
            else
            {
                return;
            }

            PreprocessConsts(def);

            FormatComment(0, def.Comment);
            Out(0, "public static class {0}", def.Name);
            Out(0, "{");
            foreach (var constant in def.Constants)
            {
                FormatComment(1, constant.Comment);
                Indent(1);
                Writer.Write("public const {0} {1}", def.NativeType, constant.Name);
                if (!String.IsNullOrEmpty(constant.Value))
                {
                    Writer.Write(" = {0}", constant.Value);
                }
                Writer.Write(';');
                NewLine();
            }
            NewLine();
            Out(1, "private static ConstsInfo<{0}> info;", def.NativeType);
            NewLine();
            Out(1, "static {0}()", def.Name);
            Out(1, "{");
            Out(2, "info = new ConstsInfo<{0}>();", def.NativeType);
            foreach (var constant in def.Constants)
            {
                Out(2, "info.Add(\"{0}\", {1});", constant.Name, constant.Value);
            }
            Out(1, "}");
            NewLine();
            Out(1, "public static bool ContainsName(string name)", def.NativeType);
            Out(1, "{");
            Out(2, "return info.ContainsName(name);");
            Out(1, "}");
            NewLine();
            Out(1, "public static bool ContainsValue({0} value)", def.NativeType);
            Out(1, "{");
            Out(2, "return info.ContainsValue(value);");
            Out(1, "}");
            NewLine();
            Out(1, "public static IEnumerator<KeyValuePair<string, {0}>> GetEnumerator()", def.NativeType);
            Out(1, "{");
            Out(2, "return info.GetEnumerator();");
            Out(1, "}");
            NewLine();
            Out(1, "public static string GetName({0} value)", def.NativeType);
            Out(1, "{");
            Out(2, "return info.GetName(value);");
            Out(1, "}");
            NewLine();
            Out(1, "public static {0} Parse(string name)", def.NativeType);
            Out(1, "{");
            Out(2, "return info.Parse(name);");
            Out(1, "}");
            NewLine();
            Out(1, "public static bool TryParse(string name, out {0} result)", def.NativeType);
            Out(1, "{");
            Out(2, "return info.TryParse(name, out result);");
            Out(1, "}");
            Out(0, "}");
        }

        public override void FormatReference(Reference def)
        {
            Out(0, "using {0};", def.Target.Replace('/', '.'));
            NewLine();
        }

        private void FormatFields(CellDef def)
        {
            foreach (var property in def.Properties)
            {
                Out(1, "private {0} {1};", property.NativeType, property.NativeName);
            }
        }

        private void FormatProperties(CellDef def)
        {
            var leading = true;
            foreach (var property in def.Properties)
            {
                if (leading)
                {
                    leading = false;
                }
                else
                {
                    NewLine();
                }

                FormatComment(1, property.Comment);

                Out(1, "public {0} {1}", property.NativeType, property.Name);
                Out(1, "{");
                Out(2, "get {{ return {0}; }}", property.NativeName);
                Out(2, "set");
                Out(2, "{");
                Out(3, "fingerprint.Touch(tag.Offset + {0});", property.Index);
                Out(3, "{0} = value;", property.NativeName);
                Out(2, "}");
                Out(1, "}");

                string name = property.Name;
                if (name.StartsWith('@'))
                {
                    name = name.Substring(1);
                }
                Out(1, "public bool _{1}_", property.NativeType, name);
                Out(1, "{");
                Out(2, "get {{ return fingerprint.Get({0}); }}", property.Index);
                Out(1, "}");
            }
        }

        private void FormatMethods(CellDef def)
        {
            FormatStaticConstructor(def);
            NewLine();
            FormatConstructor(def);
            NewLine();
            FormatEqualsTo(def);
            NewLine();
            FormatGetHashCode(def);
            NewLine();
            FormatGetType(def);
            NewLine();
            FormatIsEquivalent(def);
            if (!def.IsLocal)
            {
                NewLine();
                FormatDeserialize(def);
                NewLine();
                FormatSerialize(def);
            }
            NewLine();
            FormatDescribe(def);
            if (!def.IsLocal)
            {
                NewLine();
                FormatInitializer(def);
            }
        }

        private void FormatStaticConstructor(CellDef def)
        {
            string baseTag = def.Base;
            if (String.IsNullOrEmpty(baseTag))
            {
                baseTag = (def.IsEvent ? "Event.tag" : "null");
            }
            else
            {
                baseTag += ".tag";
            }
            Out(1, "static {0}()", def.Name);
            Out(1, "{");
            Indent(2);
            Writer.Write("tag = new Tag({0}, typeof({1}), {2}", baseTag, def.Name,
                def.Properties.Count);
            if (def.IsEvent)
            {
                int i;
                string s = ((EventDef)def).Id;
                Writer.WriteLine(",");
                Writer.Write("                    ");
                if (!Int32.TryParse(s, out i))
                {
                    Writer.Write("(int)");
                }
                Writer.Write("{0}", s);
            }
            Writer.WriteLine(");");
            Out(1, "}");

            if (def.IsEvent)
            {
                NewLine();
                Out(1, "public new static {0} New()", def.Name);
                Out(1, "{");
                Out(2, "return new {0}();", def.Name);
                Out(1, "}");
            }
        }

        private void FormatConstructor(CellDef def)
        {
            Out(1, "public {0}()", def.Name);
            Out(2, ": base(tag.NumProps)");
            Out(1, "{");
            if (!def.IsLocal)
            {
                Out(2, "Initialize();");
            }
            Out(1, "}");
            NewLine();
            Out(1, "protected {0}(int length)", def.Name);
            Out(2, ": base(length + tag.NumProps)");
            Out(1, "{");
            if (!def.IsLocal)
            {
                Out(2, "Initialize();");
            }
            Out(1, "}");
        }

        private void FormatEqualsTo(CellDef def)
        {
            Out(1, "protected override bool EqualsTo(Cell other)");
            Out(1, "{");
            Out(2, "if (!base.EqualsTo(other))");
            Out(2, "{");
            Out(3, "return false;");
            Out(2, "}");
            if (def.HasProperties)
            {
                Out(2, "{0} o = ({0})other;", def.Name);
                foreach (var property in def.Properties)
                {
                    if (Types.IsCollective(property.TypeSpec.Type))
                    {
                        Out(2, "if (!{0}.EqualsEx(o.{0}))", property.NativeName);
                    }
                    else
                    {
                        Out(2, "if ({0} != o.{0})", property.NativeName);
                    }
                    Out(2, "{");
                    Out(3, "return false;");
                    Out(2, "}");
                }
            }
            Out(2, "return true;");
            Out(1, "}");
        }

        private void FormatGetHashCode(CellDef def)
        {
            Out(1, "public override int GetHashCode(Fingerprint fingerprint)");
            Out(1, "{");
            Out(2, "var hash = new Hash(base.GetHashCode(fingerprint));");
            if (def.HasProperties)
            {
                Out(2, "if (fingerprint.Length <= tag.Offset)");
                Out(2, "{");
                Out(3, "return hash.Code;");
                Out(2, "}");

                Out(2, "var touched = new Capo<bool>(fingerprint, tag.Offset);");
                foreach (var property in def.Properties)
                {
                    Out(2, "if (touched[{0}])", property.Index);
                    Out(2, "{");
                    Out(3, "hash.Update(tag.Offset + {0});", property.Index);
                    Out(3, "hash.Update({0});", property.NativeName);
                    Out(2, "}");
                }
            }
            Out(2, "return hash.Code;");
            Out(1, "}");
        }

        private void FormatGetType(CellDef def)
        {
            if (def.IsEvent)
            {
                Out(1, "public override int GetTypeId()");
                Out(1, "{");
                Out(2, "return tag.TypeId;");
                Out(1, "}");
                NewLine();
            }

            Out(1, "public override Cell.Tag GetTypeTag() ");
            Out(1, "{");
            Out(2, "return tag;");
            Out(1, "}");

            if (def.IsEvent)
            {
                NewLine();
                Out(1, "public override Func<Event> GetFactoryMethod()");
                Out(1, "{");
                Out(2, "return {0}.New;", def.Name);
                Out(1, "}");
            }
        }

        private void FormatIsEquivalent(CellDef def)
        {
            Out(1, "protected override bool IsEquivalent(Cell other, Fingerprint fingerprint)");
            Out(1, "{");
            Out(2, "if (!base.IsEquivalent(other, fingerprint))");
            Out(2, "{");
            Out(3, "return false;");
            Out(2, "}");
            if (def.HasProperties)
            {
                Out(2, "{0} o = ({0})other;", def.Name);
                Out(2, "var touched = new Capo<bool>(fingerprint, tag.Offset);");

                foreach (var property in def.Properties)
                {
                    Out(2, "if (touched[{0}])", property.Index);
                    Out(2, "{");
                    if (Types.IsCollective(property.TypeSpec.Type))
                    {
                        Out(3, "if (!{0}.EqualsEx(o.{0}))", property.NativeName);
                    }
                    else
                    {
                        Out(3, "if ({0} != o.{0})", property.NativeName);
                    }
                    Out(3, "{");
                    Out(4, "return false;");
                    Out(3, "}");
                    Out(2, "}");
                }
            }
            Out(2, "return true;");
            Out(1, "}");
        }

        private void FormatDeserialize(CellDef def)
        {
            // Deserialize(Deserializer)
            Out(1, "public override void Deserialize(Deserializer deserializer)");
            Out(1, "{");
            Out(2, "base.Deserialize(deserializer);");
            if (def.HasProperties)
            {
                Out(2, "var touched = new Capo<bool>(fingerprint, tag.Offset);");
                foreach (var property in def.Properties)
                {
                    Out(2, "if (touched[{0}])", property.Index);
                    Out(2, "{");
                    Out(3, "deserializer.Read(out {0});", property.NativeName);
                    Out(2, "}");
                }
            }
            Out(1, "}");
        }

        private void FormatSerialize(CellDef def)
        {
            // GetLength
            Out(1, "public override int GetLength(Type targetType, ref bool flag)");
            Out(1, "{");
            Out(2, "int length = base.GetLength(targetType, ref flag);");
            Out(2, "if (!flag) { return length; }");
            if (def.HasProperties)
            {
                Out(2, "var touched = new Capo<bool>(fingerprint, tag.Offset);");
                foreach (var property in def.Properties)
                {
                    Out(2, "if (touched[{0}])", property.Index);
                    Out(2, "{");
                    Out(3, "length += Serializer.GetLength({0});", property.NativeName);
                    Out(2, "}");
                }
            }
            Out(2, "if (targetType != null && targetType == typeof({0}))", def.Name);
            Out(2, "{");
            Out(3, "flag = false;");
            Out(2, "}");
            Out(2, "return length;");
            Out(1, "}");

            // Serialize(Serializer)
            NewLine();
            Out(1, "public override void Serialize(Serializer serializer,");
            Out(2, "Type targetType, ref bool flag)");
            Out(1, "{");
            Out(2, "base.Serialize(serializer, targetType, ref flag);");
            Out(2, "if (!flag) { return; }");
            if (def.HasProperties)
            {
                Out(2, "var touched = new Capo<bool>(fingerprint, tag.Offset);");
                foreach (var property in def.Properties)
                {
                    Out(2, "if (touched[{0}])", property.Index);
                    Out(2, "{");
                    Out(3, "serializer.Write({0});", property.NativeName);
                    Out(2, "}");
                }
            }
            Out(2, "if (targetType != null && targetType == typeof({0}))", def.Name);
            Out(2, "{");
            Out(3, "flag = false;");
            Out(2, "}");
            Out(1, "}");
        }

        private void FormatDescribe(CellDef def)
        {
            Out(1, "protected override void Describe(StringBuilder stringBuilder)");
            Out(1, "{");
            Out(2, "base.Describe(stringBuilder);");
            foreach (var property in def.Properties)
            {
                Out(2, "stringBuilder.AppendFormat(\" {0}:{{0}}\", {1}.ToStringEx());",
                    property.Name, property.NativeName);
            }
            Out(1, "}");
        }

        private void FormatInitializer(CellDef def)
        {
            Out(1, "private void Initialize()");
            Out(1, "{");
            foreach (var property in def.Properties)
            {
                Out(2, "{0} = {1};", property.NativeName, property.DefaultValue);
            }
            Out(1, "}");
        }

        private void FormatComment(int indent, string text)
        {
            if (String.IsNullOrEmpty(text)) { return; }
            string[] lines = text.Split(new char[] { '\n', '\r' },
                StringSplitOptions.RemoveEmptyEntries);
            Out(indent, "/// <summary>");
            for (int i = 0; i < lines.Length; ++i)
            {
                Out(indent, "/// {0}", lines[i]);
            }
            Out(indent, "/// </summary>");
        }

        private static void PreprocessConsts(ConstsDef def)
        {
            if (def.Type == "string")
            {
                foreach (var constant in def.Constants)
                {
                    constant.Value = "\"" + constant.Value + "\"";
                }
            }
        }

        private static void PreprocessProperties(CellDef def)
        {
            int index = 0;
            foreach (var property in def.Properties)
            {
                property.Index = index++;

                property.Name = property.Name.TrimStart(' ', '\t', '\n', '\r', '_');
                property.Name = property.Name.TrimEnd(' ', '\t', '\n', '\r', '_');

                property.NativeName = FirstToLower(property.Name) + "_";
                if (!def.IsLocal && !def.AsIs)
                {
                    property.Name = FirstToUpper(property.Name);
                }

                // Avoid keywords
                if (isKeyword(property.Name))
                {
                    property.Name = "@" + property.Name;
                }
                if (isKeyword(property.NativeName))
                {
                    property.NativeName = "@" + property.NativeName;
                }

                if (Types.IsPrimitive(property.TypeSpec.Type))
                {
                    if (String.IsNullOrEmpty(property.DefaultValue))
                    {
                        property.DefaultValue = defaultValues[property.TypeSpec.Type];
                    }
                    if (property.TypeSpec.Type == "string")
                    {
                        property.DefaultValue = "\"" + property.DefaultValue + "\"";
                    }
                }
                else
                {
                    property.DefaultValue = "null";
                }

                property.NativeType = FormatTypeSpec(property.TypeSpec);
            }
        }

        private static string FormatTypeSpec(TypeSpec typeSpec)
        {
            string type = typeSpec.Type;
            if (!Types.IsBuiltin(type))
            {
                return type;  // custom type
            }
            return Types.IsPrimitive(type) ? nativeTypes[type]
                                           : FormatCollectiveType(typeSpec);
        }

        private static string FormatCollectiveType(TypeSpec typeSpec)
        {
            var sb = new StringBuilder(nativeTypes[typeSpec.Type]);
            if ((object)typeSpec.Details != null)
            {
                sb.Append('<');
                var leading = true;
                foreach (var detail in typeSpec.Details)
                {
                    if (leading)
                    {
                        leading = false;
                    }
                    else
                    {
                        sb.Append(", ");
                    }
                    sb.Append(FormatTypeSpec(detail));
                }
                sb.Append('>');
            }
            return sb.ToString();
        }

        #region WriterMethods

        private void Out(int indent, string format)
        {
            Indent(indent);
            Writer.WriteLine(format);
        }

        private void Out(int indent, string format, object arg0)
        {
            Indent(indent);
            Writer.WriteLine(format, arg0);
        }

        private void Out(int indent, string format, object arg0, object arg1)
        {
            Indent(indent);
            Writer.WriteLine(format, arg0, arg1);
        }

        private void Out(int indent, string format, object arg0, object arg1, object arg2)
        {
            Indent(indent);
            Writer.WriteLine(format, arg0, arg1, arg2);
        }

        private void Out(int indent, string format, object[] args)
        {
            Indent(indent);
            Writer.WriteLine(format, args);
        }

        public void NewLine()
        {
            Writer.WriteLine();
        }

        #endregion

        #region Indentation

        public void Indent()
        {
            ++baseIndentation;
        }

        public void Unindent()
        {
            --baseIndentation;
        }

        private void Indent(int level)
        {
            for (int i = 0; i < (baseIndentation + level); ++i)
            {
                Writer.Write(Tab);
            }
        }

        #endregion

        private static string FirstToLower(string s)
        {
            if (!String.IsNullOrEmpty(s))
            {
                var chars = s.ToCharArray();
                if (Char.IsUpper(chars[0]))
                {
                    chars[0] = Char.ToLower(chars[0]);
                    return new string(chars);
                }
            }
            return s;
        }

        private static string FirstToUpper(string s)
        {
            if (!String.IsNullOrEmpty(s))
            {
                var chars = s.ToCharArray();
                if (Char.IsLower(chars[0]))
                {
                    chars[0] = Char.ToUpper(chars[0]);
                    return new string(chars);
                }
            }
            return s;
        }

        private static bool isKeyword(string s)
        {
            return keywords.Contains(s);
        }
    }
}
